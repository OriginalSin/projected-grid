<!DOCTYPE html>
<html lang="en">
	<head>
		<meta charset="utf-8">
		<title>CDLOD Plane - Jérémy BOUNY</title>
		<link href="style.css" rel="stylesheet">
		<meta name="apple-mobile-web-app-capable" content="yes" />
		<meta name="mobile-web-app-capable" content="yes" />
		<meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no" />
	</head>

	<body>	
		<div id="canvas-3d" class="viewer"></div>
		
		<script id="vertexShader" type="x-shader/x-vertex">

			precision mediump float;
			precision mediump int;

			uniform float time;

			uniform mat4 modelViewMatrix;
			uniform mat4 projectionMatrix;

			attribute vec3 position;
			
			varying vec4 vWorldPosition;

			const vec3 groundNormal = vec3( 0.0, 1.0, 0.0 );
			const float groundHeight = 0.0;
			const float screenScale = 1.2;
			const float infinite = 10000000000.0;

			vec3 interceptPlane( in vec3 source, in vec3 dir, in vec3 normal, float height )
			{
				// Compute the distance between the source and the surface, following a ray, then return the intersection
				float distance = ( height - dot( normal, source ) ) / dot( dir, normal );
				if( distance < 0.0 )
					return source + dir * distance;
				else 
					return vec3( source.x, 0.0, source.z ) - vec3( dir.x, 0.0, dir.z ) * infinite;
			}
			
			mat3 getRotation()
			{
				// Extract the 3x3 rotation matrix from the 4x4 model view matrix
				return mat3( 
					modelViewMatrix[0].xyz,
					modelViewMatrix[1].xyz,
					modelViewMatrix[2].xyz
				);
			}
			
			vec3 getCameraPos( in mat3 rotation )
			{
				// Xc = R * Xw + t
				// c = - R.t() * t <=> c = - t.t() * R
				return - modelViewMatrix[3].xyz * rotation;
			}

			vec2 getImagePlan(vec2 coord)
			{				
				// Extracting aspect from projection matrix:
				// P = | e   0       0   0 |
				//     | 0   e/(h/w) 0   0 |
				//     | 0   0       .   . |
				//     | 0   0       -1  0 |
				float focal = projectionMatrix[0][0];
				float aspect = projectionMatrix[1][1] / focal;
				
				// Fix coordinate aspect and scale
				return vec2( coord.x * aspect * screenScale, coord.y / aspect * screenScale );
			}
			
			vec3 getCamRay( in mat3 rotation, in vec2 screenUV )
			{				
				// Compute camera ray then rotate it in order to get it in world coordinate
				return normalize( vec3( screenUV.x, screenUV.y, projectionMatrix[0][0] ) * rotation );
			}
			
			vec3 compteProjectedPosition()
			{
				// Extract camera position and rotation from the model view matrix
				mat3 cameraRotation = getRotation();
				vec3 cameraPosition = getCameraPos( cameraRotation );
			
				// Extract coordinate of the vertex on the image plan
				vec2 screenUV = getImagePlan( ( projectionMatrix * vec4( position, 1.0 ) ).xy ) ;
				
				// Compute the ray from camera to world
				vec3 ray = getCamRay( cameraRotation, screenUV );
				
				// Return the intersection between the camera ray and a given plane
				return interceptPlane( cameraPosition, ray, groundNormal, groundHeight );
			}
			
			float getHeight( vec2 inDir ) {
				float height = ( sin( vWorldPosition.x * inDir.x + time * 0.1 ) * 1.9 + cos( vWorldPosition.z * inDir.y + time * 0.1 ) * 0.3 ) ;
				return height * height * height ;
			}

			void main()
			{
				// Compute the real position of the vertex on the plane
				vWorldPosition = vec4( compteProjectedPosition(), 1.0 );
				
				// Add noise on height
				float height = getHeight( vec2( 0.3565, 0.265 ) ) * 0.5 + 
							   getHeight( vec2( 0.07565, 0.0865 ) ) * 2.0 + 
							   getHeight( vec2( 0.8, 0.99 ) ) * 0.2;
				vWorldPosition.y += height ;
				
				gl_Position = projectionMatrix * modelViewMatrix * vWorldPosition;
				
			}

		</script>

		<script id="fragmentShader" type="x-shader/x-fragment">

			precision mediump float;
			precision mediump int;

			uniform float time;
			
			varying vec4 vWorldPosition;

			void main()	
			{
				gl_FragColor = vec4( vec3( ( vWorldPosition.y + 25.0 ) / 100.0 ), 1.0 );
				gl_FragColor.b *= 2.0 ;
			}

		</script>
		
		<!-- External libraries -->	
		<script src="../../libs/three.js/index.js"></script>
		<script src="../../libs/OrbitControl/index.js"></script>
		<script src="../../libs/zepto/zepto.min.js"></script>
		
		<!-- Demo files -->
		<script src="demo.js"></script>
	</body>
</html>