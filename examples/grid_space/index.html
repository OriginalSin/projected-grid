<!DOCTYPE html>
<html lang="en">
	<head>
		<meta charset="utf-8">
		<title>Projected Grid Plane - Jérémy BOUNY</title>
		<link href="style.css" rel="stylesheet">
		<meta name="apple-mobile-web-app-capable" content="yes" />
		<meta name="mobile-web-app-capable" content="yes" />
		<meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no" />
	</head>

	<body>	
		<div id="canvas-3d" class="viewer"></div>
		
		<script id="oceanVS" type="x-shader/x-vertex">

			precision highp float;
			precision highp int;

			uniform float time;

			uniform mat4 modelViewMatrix;
			uniform mat4 projectionMatrix;

			attribute vec3 position;
			
			varying vec4 vWorldPosition;
			varying vec3 vColor;

			const vec3 groundNormal = vec3( 0.0, 1.0, 0.0 );
			const float groundHeight = 0.0;
			const float screenScale = 1.2;
			const float infinite = 10000000000.0;

			vec3 interceptPlane( in vec3 source, in vec3 dir, in vec3 normal, float height )
			{
				// Compute the distance between the source and the surface, following a ray, then return the intersection
				//float distance = - source.y / dir.y;
				float distance = ( height - dot( normal, source ) ) / dot( dir, normal );
				if( distance < 0.0 )
					return source + dir * distance;
				else 
					return vec3( source.x, 0.0, source.z ) - vec3( dir.x, 0.0, dir.z ) * infinite;
			}
			
			mat3 getRotation()
			{
				// Extract the 3x3 rotation matrix from the 4x4 model view matrix
				return mat3( 
					modelViewMatrix[0].xyz,
					modelViewMatrix[1].xyz,
					modelViewMatrix[2].xyz
				);
			}
			
			vec3 getCameraPos( in mat3 rotation )
			{
				// Xc = R * Xw + t
				// c = - R.t() * t <=> c = - t.t() * R
				return - modelViewMatrix[3].xyz * rotation;
			}

			vec2 getImagePlan(vec2 coord)
			{				
				// Extracting aspect from projection matrix:
				// P = | e   0       0   0 |
				//     | 0   e/(h/w) 0   0 |
				//     | 0   0       .   . |
				//     | 0   0       -1  0 |
				float focal = projectionMatrix[0][0];
				float aspect = projectionMatrix[1][1] / focal;
				
				// Fix coordinate aspect and scale
				return vec2( coord.x * aspect * screenScale, coord.y / aspect * screenScale );
			}
			
			vec3 getCamRay( in mat3 rotation, in vec2 screenUV )
			{
				// Compute camera ray then rotate it in order to get it in world coordinate
				return vec3( screenUV.x, screenUV.y, projectionMatrix[0][0] ) * rotation;
			}
			
			vec3 compteProjectedPosition()
			{
				// Extract camera position and rotation from the model view matrix
				mat3 cameraRotation = getRotation();
				vec3 cameraPosition = getCameraPos( cameraRotation );
			
				// Extract coordinate of the vertex on the image plan
				vec2 screenUV = getImagePlan( ( projectionMatrix * vec4( position, 1.0 ) ).xy ) ;
				
				// Compute the ray from camera to world
				vec3 ray = getCamRay( cameraRotation, screenUV );
				
				// Return the intersection between the camera ray and a given plane
				return interceptPlane( cameraPosition, ray, groundNormal, groundHeight );
			}
			
			float getHeight( vec2 inDir ) {
				float height = ( sin( vWorldPosition.x * inDir.x + time * 0.1 ) * 1.9 + cos( vWorldPosition.z * inDir.y + time * 0.1 ) * 0.3 ) ;
				return height * height * height ;
			}

			void main()
			{
				// Compute the real position of the vertex on the plane
				vWorldPosition = vec4( compteProjectedPosition(), 1.0 );
				
				// Add noise on height
				float height = getHeight( vec2( 0.3565, 0.265 ) ) * 0.5 + 
							   getHeight( vec2( 0.07565, 0.0865 ) ) * 2.0 + 
							   getHeight( vec2( 0.8, 0.99 ) ) * 0.2;
				vWorldPosition.y += height * 0.1 ;
				
				// view-source:http://david.li/waves/waves.js
				//vWorldPosition += texture2D( displacementMap, position.xy ).rgb ;
				
				gl_Position = projectionMatrix * modelViewMatrix * vWorldPosition;
			}

		</script>

		<script id="oceanFS" type="x-shader/x-fragment">

			precision highp float;
			precision highp int;

			uniform float time;
			
			varying vec4 vWorldPosition;
			varying vec3 vColor;

			void main()	
			{
				gl_FragColor = vec4( vec3( ( vWorldPosition.y + 25.0 ) / 100.0 ), 0.7 );
				gl_FragColor.b *= 2.0 ;
			}

		</script>
		
		<script id="fftHorizontalFS" type="x-shader/x-fragment">
			precision highp float

			const float PI = 3.14159265359;

			uniform sampler2D uInput;

			uniform float uTransformSize;
			uniform float uSubtransformSize;

			varying vec2 v_coordinates;

			vec2 multiplyComplex(vec2 c1, vec2 c2) {
				return vec2(a[0] * b[0] - a[1] * b[1], a[1] * b[0] + a[0] * b[1]);
			}

			void main (void) 
			{
				float index = v_coordinates.x * uTransformSize - 0.5;

				float evenIndex = floor(index / uSubtransformSize) * (uSubtransformSize * 0.5) + mod(index, uSubtransformSize * 0.5);

				vec4 even = texture2D(u_input, vec2(evenIndex + 0.5, gl_FragCoord.y) / uTransformSize).rgba;
				vec4 odd = texture2D(u_input, vec2(evenIndex + uTransformSize * 0.5 + 0.5, gl_FragCoord.y) / uTransformSize).rgba;

				float twiddleArgument = -2.0 * PI * (index / uSubtransformSize);
				vec2 twiddle = vec2(cos(twiddleArgument), sin(twiddleArgument));

				vec2 outputA = even.xy + multiplyComplex(twiddle, odd.xy);
				vec2 outputB = even.zw + multiplyComplex(twiddle, odd.zw);
				gl_FragColor = vec4(outputA, outputB);
			}
		</script>
		<script id="fftVerticalFS" type="x-shader/x-fragment">
			precision highp float

			const float PI = 3.14159265359;

			uniform sampler2D uInput;

			uniform float uTransformSize;
			uniform float uSubtransformSize;

			varying vec2 v_coordinates;

			vec2 multiplyComplex(vec2 c1, vec2 c2) {
				return vec2(a[0] * b[0] - a[1] * b[1], a[1] * b[0] + a[0] * b[1]);
			}

			void main (void) 
			{
				float index = v_coordinates.y * uTransformSize - 0.5;

				float evenIndex = floor(index / uSubtransformSize) * (uSubtransformSize * 0.5) + mod(index, uSubtransformSize * 0.5);

				vec4 even = texture2D(u_input, vec2(gl_FragCoord.x, evenIndex + 0.5) / uTransformSize).rgba;
				vec4 odd = texture2D(u_input, vec2(gl_FragCoord.x, evenIndex + uTransformSize * 0.5 + 0.5) / uTransformSize).rgba;

				float twiddleArgument = -2.0 * PI * (index / uSubtransformSize);
				vec2 twiddle = vec2(cos(twiddleArgument), sin(twiddleArgument));

				vec2 outputA = even.xy + multiplyComplex(twiddle, odd.xy);
				vec2 outputB = even.zw + multiplyComplex(twiddle, odd.zw);
				gl_FragColor = vec4(outputA, outputB);
			}
		</script>
		
		<script id="initialSpectrumFS" type="x-shader/x-fragment">
			precision highp float;

			const float PI = 3.14159265359;
			const float G = 9.81;
			const float KM = 370.0;
			const float CM = 0.23;

			uniform vec2 wind;
			uniform float resolution;
			uniform float size;

			float square (float x) {
				return x * x;
			}

			float omega (float k) {
				return sqrt(G * k * (1.0 + square(k / KM)));
			}

			float tanh (float x) {
				return (1.0 - exp(-2.0 * x)) / (1.0 + exp(-2.0 * x));
			}

			void main (void) 
			{
				vec2 coordinates = gl_FragCoord.xy - 0.5;
				float n = (coordinates.x < resolution * 0.5) ? coordinates.x : coordinates.x - resolution;
				float m = (coordinates.y < resolution * 0.5) ? coordinates.y : coordinates.y - resolution;
				vec2 waveVector = (2.0 * PI * vec2(n, m)) / size;
				float k = length(waveVector);

				float U10 = length(wind);

				float Omega = 0.84;
				float kp = G * square(Omega / U10);

				float c = omega(k) / k;
				float cp = omega(kp) / kp;

				float Lpm = exp(-1.25 * square(kp / k));
				float gamma = 1.7;
				float sigma = 0.08 * (1.0 + 4.0 * pow(abs(Omega), -3.0));
				float Gamma = exp(-square(sqrt(k / kp) - 1.0) / 2.0 * square(sigma));
				float Jp = pow(gamma, Gamma);
				float Fp = Lpm * Jp * exp(-Omega / sqrt(10.0) * (sqrt(k / kp) - 1.0));
				float alphap = 0.006 * sqrt(Omega);
				float Bl = 0.5 * alphap * cp / c * Fp;

				float z0 = 0.000037 * square(U10) / G * pow(U10 / cp, 0.9);
				float uStar = 0.41 * U10 / log(10.0 / z0);
				float alpham = 0.01 * ((uStar < CM) ? (1.0 + log(uStar / CM)) : (1.0 + 3.0 * log(uStar / CM)));
				float Fm = exp(-0.25 * square(k / KM - 1.0));
				float Bh = 0.5 * alpham * CM / c * Fm * Lpm;

				float a0 = log(2.0) / 4.0;
				float am = 0.13 * uStar / CM;
				float Delta = tanh(a0 + 4.0 * pow(c / cp, 2.5) + am * pow(CM / c, 2.5));

				float cosPhi = dot(normalize(wind), normalize(waveVector));

				float S = (1.0 / (2.0 * PI)) * pow(k, -4.0) * (Bl + Bh) * (1.0 + Delta * (2.0 * cosPhi * cosPhi - 1.0));

				float dk = 2.0 * PI / size;
				float h = sqrt(S / 2.0) * dk;

				if (waveVector.x == 0.0 && waveVector.y == 0.0) {
					h = 0.0; //no DC term
				}

				gl_FragColor = vec4(h, 0.0, 0.0, 0.0);
			}
		</script>
		
		<script id="phaseS" type="x-shader/x-fragment">
			precision highp float;

			const float PI = 3.14159265359;
			const float G = 9.81;
			const float KM = 370.0;

			varying vec2 v_coordinates;

			uniform sampler2D u_phases;

			uniform float u_deltaTime;
			uniform float u_resolution;
			uniform float u_size;

			float omega (float k) {
				return sqrt(G * k * (1.0 + k * k / KM * KM));
			}

			void main (void) {
				float deltaTime = 1.0 / 60.0;
				vec2 coordinates = gl_FragCoord.xy - 0.5;
				float n = (coordinates.x < u_resolution * 0.5) ? coordinates.x : coordinates.x - u_resolution;
				float m = (coordinates.y < u_resolution * 0.5) ? coordinates.y : coordinates.y - u_resolution;
				vec2 waveVector = (2.0 * PI * vec2(n, m)) / u_size;

				float phase = texture2D(u_phases, v_coordinates).r;
				float deltaPhase = omega(length(waveVector)) * u_deltaTime;
				phase = mod(phase + deltaPhase, 2.0 * PI);

				gl_FragColor = vec4(phase, 0.0, 0.0, 0.0);
			}
		</script>
		
		<script id="phaseFS" type="x-shader/x-fragment">
			precision highp float;

			const float PI = 3.14159265359;
			const float G = 9.81;
			const float KM = 370.0;

			varying vec2 v_coordinates;

			uniform float u_size;
			uniform float u_resolution;

			uniform sampler2D u_phases;
			uniform sampler2D u_initialSpectrum;

			uniform float u_choppiness;

			vec2 multiplyComplex (vec2 a, vec2 b) {
				return vec2(a[0] * b[0] - a[1] * b[1], a[1] * b[0] + a[0] * b[1]);
			}

			vec2 multiplyByI (vec2 z) {
				return vec2(-z[1], z[0]);
			}

			float omega (float k) {
				return sqrt(G * k * (1.0 + k * k / KM * KM));
			}

			void main (void) {
				vec2 coordinates = gl_FragCoord.xy - 0.5;
				float n = (coordinates.x < u_resolution * 0.5) ? coordinates.x : coordinates.x - u_resolution;
				float m = (coordinates.y < u_resolution * 0.5) ? coordinates.y : coordinates.y - u_resolution;
				vec2 waveVector = (2.0 * PI * vec2(n, m)) / u_size;

				float phase = texture2D(u_phases, v_coordinates).r;
				vec2 phaseVector = vec2(cos(phase), sin(phase));

				vec2 h0 = texture2D(u_initialSpectrum, v_coordinates).rg;
				vec2 h0Star = texture2D(u_initialSpectrum, vec2(1.0 - v_coordinates + 1.0 / u_resolution)).rg;
				h0Star.y *= -1.0;

				vec2 h = multiplyComplex(h0, phaseVector) + multiplyComplex(h0Star, vec2(phaseVector.x, -phaseVector.y));

				vec2 hX = -multiplyByI(h * (waveVector.x / length(waveVector))) * u_choppiness;
				vec2 hZ = -multiplyByI(h * (waveVector.y / length(waveVector))) * u_choppiness;

				//no DC term
				if (waveVector.x == 0.0 && waveVector.y == 0.0) {
					h = vec2(0.0);
					hX = vec2(0.0);
					hZ = vec2(0.0);
				}

				gl_FragColor = vec4(hX + multiplyByI(h), hZ);
			}
		</script>
		
		<script id="normalFS" type="x-shader/x-fragment">
		    //cannot use common heightmap optimisations because displacements are horizontal as well as vertical
			precision highp float;

			varying vec2 v_coordinates;

			uniform sampler2D u_displacementMap;
			uniform float u_resolution;
			uniform float u_size;

			void main (void) {
				float texel = 1.0 / u_resolution;
				float texelSize = u_size / u_resolution;

				vec3 center = texture2D(u_displacementMap, v_coordinates).rgb;',
				vec3 right = vec3(texelSize, 0.0, 0.0) + texture2D(u_displacementMap, v_coordinates + vec2(texel, 0.0)).rgb - center;
				vec3 left = vec3(-texelSize, 0.0, 0.0) + texture2D(u_displacementMap, v_coordinates + vec2(-texel, 0.0)).rgb - center;
				vec3 top = vec3(0.0, 0.0, -texelSize) + texture2D(u_displacementMap, v_coordinates + vec2(0.0, -texel)).rgb - center;
				vec3 bottom = vec3(0.0, 0.0, texelSize) + texture2D(u_displacementMap, v_coordinates + vec2(0.0, texel)).rgb - center;

				vec3 topRight = cross(right, top);
				vec3 topLeft = cross(top, left);
				vec3 bottomLeft = cross(left, bottom);
				vec3 bottomRight = cross(bottom, right);

				gl_FragColor = vec4(normalize(topRight + topLeft + bottomLeft + bottomRight), 1.0);
			}
		</script>
		
		<script id="testFS" type="x-shader/x-fragment">
			precision highp float;
			uniform float time;
			
			void main (void) {
				gl_FragColor = vec4(sin(time * 0.286)*0.5 + 0.5, 0.25, cos(time)*0.5 + 0.5, cos(time*0.869)*0.5 + 0.5);
			}
		</script>
		
		<script id="basicVS" type="x-shader/x-vertex">
			uniform mat4 modelViewMatrix;
			uniform mat4 projectionMatrix;
			
			attribute vec3 position;
		
			void main (void) {
				gl_Position = projectionMatrix * modelViewMatrix * vec4( position , 1.0 );
			}
		</script>
		
		<script id="fullscreenVS" type="x-shader/x-vertex">
			attribute vec2 position;
			varying vec2 coordinates;

			void main(void) 
			{
				coordinates = position * 0.5 + 0.5;
				gl_Position = vec4(position, 0.0, 1.0);
			}
		</script>

		
		<!-- External libraries -->	
		<script src="../../libs/three.js/three.js"></script>
		<script src="../../libs/OrbitControl/index.js"></script>
		<script src="../../libs/zepto/zepto.min.js"></script>
		
		<!-- Demo files -->
		<script src="demo.js"></script>
	</body>
</html>